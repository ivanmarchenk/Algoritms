public class AWQ {
    static int NO_OF_CHARS = 256;
    private static int i;

    // Полезная функция для получения максимум двух целых чисел
    static int max(int a, int b) {
        return (a > b) ? a : b;
    }

    // Функция предварительной обработки для Бойера Мура
    // эвристика неверных символов
    static void badCharHeuristic(char[] str, int size, int badchar[]) {

        // Инициализируем все вхождения как -1
        for (int i = 0; i < NO_OF_CHARS; i++)
            badchar[i] = -1;

        // Заполняем фактическое значение последнего появления символа (индексы таблицы - ascii, а значения - индекс появления)
        for (i = 0; i < size; i++)
            badchar[(int) str[i]] = i;
    }

    /* Функцция поиска по шаблону, использующая плохую эвристику характеристик для алгоритса Боейра Мура */
    static void search(char txt[], char pat[]) {
        int m = pat.length;
        int n = txt.length;

        int badchar[] = new int[NO_OF_CHARS];

      /* Заполняем массив плохих символов, вызывая
          функцию предварительной обработки badCharHeuristic ()
          для данного шаблона */
        badCharHeuristic(pat, m, badchar);

        int s = 0;
        // это сдвиг шаблона относительно текста, есть n-m + 1 потенциальных совпадений
        while (s <= (n - m)) {
            int j = m - 1;

          /* Продолжаем уменьшать индекс j шаблона, пока символы шаблона и текста совпадают на этом сдвиге s*/
            while (j >= 0 && pat[j] == txt[s + j])
                j--;

          /* Если шаблон присутствует в текущем сдвиге, то индекс j станет -1 после указанного выше цикла. */
            if (j < 0) {
                System.out.println("Patterns occur at shift = " + s);

              /* Сдвинем паттерн так, чтобы следующий символ в тексте выровнялся с последним его вхождением в паттерн.
                Условие s + m <n необходимо для случая, когда в конце текста встречается шаблон. */
                //txt[s+m] это символ после шаблона в тексте
                s += (s + m < n) ? m - badchar[txt[s + m]] : 1;

            } else
              /* Сдвинем паттерн так, чтобы неправильный символ в тексте совпадал с последним вхождением этого символа в шаблоне.
               Функция max используется, чтобы убедиться, что мы получаем положительный сдвиг.
               Мы можем получить отрицательный сдвиг, если последнее появление плохого символа в шаблоне
               находится справа от текущего символа. */
                s += max(1, j - badchar[txt[s + j]]);
        }
    }


    public static void main(String []args) {

        char txt[] = "AAAAAAAAAAAAAAAAA".toCharArray();
        char pat[] = "AAAAA".toCharArray();
        search(txt, pat);
    }
}
